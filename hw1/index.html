<!DOCTYPE html>
<html>

<head>
	<!-- MathJax 3 setup -->
	<script>
		MathJax = {
			tex: {
				inlineMath: [['$', '$'], ['\\(', '\\)']],
				displayMath: [['$$', '$$'], ['\\[', '\\]']]
			}
		};
	</script>
	<script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml.js"></script>

	<!-- Include custom font -->
	<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">

	<style>
		h1 {
			text-align: center;
		}

		.container {
			margin: 0 auto;
			padding: 60px 8%;
		}

		figure {
			text-align: center;
		}

		img {
			display: inline-block;
		}

		body {
			font-family: 'Inter', sans-serif;
		}

		p {
			text-indent: 2em;
		}
	</style>
</head>

<body>
	<div class="container">
		<h1>CS184/284A Spring 2025 Homework 1 Write-Up</h1>
		<div style="text-align: center;">Names:Gavin Jiang</div>

		<br>

		Link to webpage:
		<a href="https://cal-cs184-student.github.io/hw-webpages-jiangpf2022/">
			https://cal-cs184-student.github.io/hw-webpages-jiangpf2022/
		</a>

		<br>

		Link to GitHub repository:
		<a href="https://github.com/cal-cs184-student/sp25-hw1-sss">
			https://github.com/cal-cs184-student/sp25-hw1-sss
		</a>

		<figure>
			<img src="lion.jpg" alt="Lion" style="width:50%" />
			<figcaption>You can add images with captions!</figcaption>
		</figure>

		<!--
    We've already added one heading per task, to make your write-up as navigable when grading. Please fit your write-up within these sections!
    -->

		<h2 style="color:red">Overview</h2>
		<p>Give a high-level overview of what you implemented in this homework. Think about what you've built as
			a whole. Share your thoughts on what interesting things you've learned from completing the homework.</p>

		<h2>Task 1: Drawing Single-Color Triangles</h2>
		<h3 style="color: blue;">Walk through how you rasterize triangles in your own words.</h3>
		<p>
			To rasterize a triangle correctly, we first need to determine the <b>orientation</b> of the triangle's
			vertices. This ensures that regardless of whether the vertices are specified in <b>clockwise</b> or
			<b>counterclockwise</b> order, the triangle is correctly rendered. We achieve this by computing the
			signed area of the triangle:
		</p>

		\[
		A = (x_1 - x_0) (y_2 - y_0) - (y_1 - y_0) (x_2 - x_0)
		\]

		<p>
			If \( A < 0 \), the triangle is specified in a clockwise order, and we swap two vertices to make it
				counterclockwise. This standardizes the calculations and ensures proper filling. </p>

				<p>
					Next, we determine the <b>direction of the three edges</b> by computing their differences:
				</p>

				\[
				dx_0 = x_1 - x_0, \quad dy_0 = y_1 - y_0
				\]

				\[
				dx_1 = x_2 - x_1, \quad dy_1 = y_2 - y_1
				\]

				\[
				dx_2 = x_0 - x_2, \quad dy_2 = y_0 - y_2
				\]

				<p>
					To optimize rasterization, we compute the <b>bounding box</b> of the triangle. Instead of checking
					every pixel in the entire image, we only check the pixels within this bounding box:
				</p>

				\[
				x_{\text{min}} = \lfloor \min(x_0, x_1, x_2) \rfloor, \quad x_{\text{max}} = \lceil \max(x_0, x_1, x_2)
				\rceil
				\]
				\[
				y_{\text{min}} = \lfloor \min(y_0, y_1, y_2) \rfloor, \quad y_{\text{max}} = \lceil \max(y_0, y_1, y_2)
				\rceil
				\]

				<p>
					For each pixel \((x, y)\) within this bounding box, we use the <b>point-in-triangle test</b> based
					on edge equations:
				</p>

				\[
				L_i (x, y) = –(x - X_i) dY_i + (y - Y_i) dX_i
				\]

				<p>
					This can also be rewritten in the form:
				</p>

				\[
				L_i (x, y) = A_i x + B_i y + C_i
				\]

				<p>
					For each pixel at <b>center position</b> \( (x+0.5, y+0.5) \), we compute \( L_1, L_2, L_3 \). If
					all three satisfy:
				</p>

				\[
				L_1 \geq 0, \quad L_2 \geq 0, \quad L_3 \geq 0
				\]

				<p>
					then the pixel is inside the triangle, and we call the <code>fill_pixel(x, y, color)</code> function
					to color it.
				</p>

				<h3 style="color: blue;">
					Explain how your algorithm is no worse than one that checks each sample within the bounding box of
					the triangle. The bounding box of the triangle is defined as the smallest rectangle that can be
					drawn
					whilst ensuring that the entire triangle is within it.
				</h3>

				<p>
					To optimize the rasterization process, my algorithm first determines the <b>bounding box</b> of
					the triangle before iterating over pixels. The bounding box is calculated as:
				</p>

				\[
				x_{\text{min}} = \lfloor \min(x_0, x_1, x_2) \rfloor, \quad x_{\text{max}} = \lceil \max(x_0, x_1, x_2)
				\rceil
				\]
				\[
				y_{\text{min}} = \lfloor \min(y_0, y_1, y_2) \rfloor, \quad y_{\text{max}} = \lceil \max(y_0, y_1, y_2)
				\rceil
				\]

				<p>
					This ensures that the algorithm only considers the smallest rectangular region containing the
					triangle, avoiding unnecessary computations outside of this area. By limiting the loop to iterate
					within this bounding box, the number of pixels checked is at most the number of pixels in the
					bounding box.
				</p>

				<p>
					Since the bounding box is the minimal enclosing rectangle for the triangle, any algorithm that
					checks each sample within the bounding box will inherently examine at least the same number of
					pixels. My approach does not perform any additional operations beyond this predefined region,
					ensuring that it is <b>no worse</b> than a naïve method that simply iterates over all pixels within
					the bounding box.
				</p>

				<h3 style="color: blue;">
					Show a png screenshot of basic/test4.svg with the default viewing parameters and with the pixel
					inspector
					centered on an interesting part of the scene.
				</h3>

				<div style="display: flex; flex-direction: column; align-items: center;">
					<table style="width: 100%; text-align: center; border-collapse: collapse;">
						<tr>
							<td style="text-align: center;">
								<img src="image/test3.png" width="400px" />
								<figcaption>test3.svg</figcaption>
							</td>
							<td style="text-align: center;">
								<img src="image/test4.png" width="400px" />
								<figcaption>test4.svg</figcaption>
							</td>
						</tr>
						<tr>
							<td style="text-align: center;">
								<img src="image/test5.png" width="400px" />
								<figcaption>test5.svg</figcaption>
							</td>
							<td style="text-align: center;">
								<img src="image/test6.png" width="400px" />
								<figcaption>test6.svg</figcaption>
							</td>
						</tr>
					</table>
				</div>

				<h3 style="color:red">
					Extra credit: Explain any special optimizations you did beyond simple bounding box triangle
					rasterization,
					with a timing comparison table (we suggest using the c++ clock() function around the svg.draw()
					command in DrawRend::redraw() to compare millisecond timings with your various optimizations off and
					on)
				</h3>

				<h4>Optimizations Implemented</h4>

				<p>
					In this extra credit task, I optimized the triangle rasterization process beyond the simple
					bounding box method.
					The following key optimizations were implemented:
				</p>

				<ul>
					<li>
						<b>Incremental Edge Function Updates:</b> Instead of recalculating edge functions for each pixel
						independently,
						we initialize them once and use incremental updates. Moving right by one pixel only requires
						adding the edge’s
						<code>A</code> coefficient, and moving down a row only requires adding <code>B</code>.
					</li>
					<li>
						<b>Bounding Box Clipping:</b> The bounding box is computed and clipped to screen limits before
						iteration,
						reducing unnecessary condition checks inside the loops.
					</li>
					<li>
						<b>Early Termination on Empty Rows:</b> Once a valid pixel is found in a row, the loop continues
						scanning,
						but if no more valid pixels can exist (due to triangle shape), it breaks early, avoiding
						unnecessary calculations.
					</li>
					<li>
						<b>Memory Access Optimization:</b> By reducing redundant memory accesses inside the loop,
						the optimized version improves cache locality and execution efficiency.
					</li>
				</ul>
				<h4>Core Code Comparison</h4>

				<p>
					The following code snippets highlight the main differences between the naive and optimized
					implementations.
				</p>

				<table border="1" style="border-collapse: collapse; text-align: left; width: 100%;">
					<tr>
						<th style="width: 50%; background-color: #f8d7da;">Naive Implementation</th>
						<th style="width: 50%; background-color: #d4edda;">Optimized Implementation</th>
					</tr>
					<tr>
						<td>
							<pre style="white-space: pre-wrap; font-size: 14px;">
// Loop over every pixel in bounding box
for(float i=x_min; i<=x_max; i++){
    for(float j=y_min; j<=y_max; j++){
        float posx = i + 0.5, posy = j + 0.5;
        float L1 = -(posx-x0)*dy0 + (posy-y0)*dx0;
        float L2 = -(posx-x1)*dy1 + (posy-y1)*dx1;
        float L3 = -(posx-x2)*dy2 + (posy-y2)*dx2;
        if (L1 >= 0 && L2 >= 0 && L3 >= 0) {
            fill_pixel(i, j, color);
        }
    }
}
            </pre>
						</td>
						<td>
							<pre style="white-space: pre-wrap; font-size: 14px;">
// Compute initial edge function values at (x_min + 0.5, y_min)
float L1_row = A0 * (x_min + 0.5) + B0 * y_min + C0;
float L2_row = A1 * (x_min + 0.5) + B1 * y_min + C1;
float L3_row = A2 * (x_min + 0.5) + B2 * y_min + C2;

// Loop per scanline, update edge function incrementally
for(int y = y_min; y <= y_max; y++){
    float L1 = L1_row, L2 = L2_row, L3 = L3_row;
    bool is_valid = false;
    
    for(int x = x_min; x <= x_max; x++){
        if (L1 >= 0 && L2 >= 0 && L3 >= 0) {
            fill_pixel(x, y, color);
            is_valid = true;
        } else if (is_valid) break; // Stop early
        L1 += A0; L2 += A1; L3 += A2;
    }

    L1_row += B0;
    L2_row += B1;
    L3_row += B2;
}
            </pre>
						</td>
					</tr>
				</table>

				<h4>Conclusion</h4>
				<h4>Timing Comparison</h4>

				<p>
					Below is a timing comparison between the naive rasterization method and the optimized version,
					recorded in microseconds (us). The tests were conducted on different test cases (test 3, 4, 5, and
					6).
				</p>

				<table border="1" style="border-collapse: collapse; text-align: center; width: 80%;">
					<tr>
						<th>Test Case</th>
						<th>Naive Rasterization Time (us)</th>
						<th>Optimized Rasterization Time (us)</th>
						<th>Speedup</th>
					</tr>
					<tr>
						<td>3</td>
						<td>13,625</td>
						<td>7,123</td>
						<td>1.91x</td>
					</tr>
					<tr>
						<td>4</td>
						<td>796</td>
						<td>641</td>
						<td>1.24x</td>
					</tr>
					<tr>
						<td>5</td>
						<td>2,500</td>
						<td>1,508</td>
						<td>1.66x</td>
					</tr>
					<tr>
						<td>6</td>
						<td>1486us</td>
						<td>832</td>
						<td>1.785x</td>
					</tr>
				</table>


				<h2>Task 2: Antialiasing by Supersampling</h2>
				<p>
					Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
					et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
					aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
					cillum
					dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
					officia deserunt mollit anim id est laborum.
				</p>

				<h2>Task 3: Transforms</h2>
				<p>
					Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
					et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
					aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
					cillum
					dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
					officia deserunt mollit anim id est laborum.
				</p>

				<h2>Task 4: Barycentric coordinates</h2>
				<p>
					Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
					et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
					aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
					cillum
					dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui
					officia deserunt mollit anim id est laborum.
				</p>

				<h2>Task 5: "Pixel sampling" for texture mapping</h2>
				<p>
					Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
					et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
					aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
					cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
					culpa qui officia deserunt mollit anim id est laborum.
				</p>

				<h2>Task 6: "Level Sampling" with mipmaps for texture mapping</h2>
				<p>
					Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
					et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
					aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
					cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
					culpa qui officia deserunt mollit anim id est laborum.
				</p>

				<h2>(Optional) Task 7: Extra Credit - Draw Something Creative!</h2>
				<p>
					Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore
					et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut
					aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse
					cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in
					culpa qui officia deserunt mollit anim id est laborum.
				</p>
				<!-- End tasks -->

				<h2>Additional Notes (please remove)</h2>
				<ul>
					<li>You can also add code if you'd like as so: <code>code code code</code></li>
					<li>If you'd like to add math equations,
						<ul>
							<li>You can write inline equations like so: \( a^2 + b^2 = c^2 \)</li>
							<li>You can write display equations like so: \[ a^2 + b^2 = c^2 \]</li>
						</ul>
					</li>
				</ul>
	</div>
</body>

</html>